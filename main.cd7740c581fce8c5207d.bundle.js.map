{"version":3,"file":"main.cd7740c581fce8c5207d.bundle.js","sources":["webpack:///./src/index.js"],"sourcesContent":["import React, { useEffect, useState, useRef, useImperativeHandle, forwardRef, useMemo } from 'react';\n// import PropTypes from 'prop-types';\nimport lottie from 'lottie-web';\nimport lottieApi from 'lottie-api/dist/lottie_api';\n\n// LottieTypes\nexport default forwardRef(function Lottie(props, ref) {\n  const { eventListeners } = props;\n  ref = ref || React.createRef({});\n  const el = useRef(null);\n  const [anim, setAnim] = useState(null);\n  // const [animData, setAnimData] = useState(null);\n  const [animApi, setAnimApi] = useState(null);\n  const [state, setState] = useState({ play: true, speed: props.speed || 1 });\n\n  // Config\n  const { loop, autoplay, rendererSettings, segments } = props.options;\n  let animationData = props.options.animationData;\n  if (animationData && animationData.default) animationData = animationData.default;\n\n  const [animationDataPrev, setAnimationDataPrev] = useState(animationData);\n\n  const options = useMemo(\n    () => ({\n      ...props.options,\n      container: el.current || null,\n      renderer: 'svg',\n      loop: loop !== false,\n      autoplay: autoplay !== false,\n      segments: segments !== false,\n      animationData,\n      rendererSettings\n    }),\n    [props, props.options]\n  );\n\n  const setSpeed = (speed = null) => {\n    // _anim = _anim || anim;\n    // if(!_anim) return;\n    // _anim.setSpeed(speed || props.speed);\n    const s = speed || props.speed;\n    setState(p => ({ ...p, speed: s }));\n  };\n\n  const setDirection = (direction = null) => {\n    // _anim = _anim || anim;\n    // if(!_anim) return;\n    // _anim.setDirection(props.direction);\n    setState(p => ({ ...p, direction: direction || props.direction }));\n  };\n\n  const setAnimationControl = _animApi => {\n    _animApi = _animApi || animApi;\n    if (!_animApi) return;\n    const { animationControl } = props;\n    if (animationControl) {\n      const properties = Object.keys(animationControl);\n\n      properties.forEach(property => {\n        const propertyPath = _animApi.getKeyPath(property);\n        const value = animationControl[property];\n        _animApi.addValueCallback(propertyPath, () => value);\n      });\n    }\n  };\n\n  const play = () => {\n    // _anim = _anim || anim;\n    // if(!_anim) return;\n    // _anim.play();\n    setState(p => ({ ...p, play: true, pause: false, segments: null }));\n  };\n\n  const playSegments = (segments, shouldForce) => {\n    // if(!anim) return;\n    setState(p => ({ ...p, segments: segments || props.segments, shouldForce: shouldForce }));\n  };\n\n  const stop = () => {\n    // if(!anim) return;\n    // anim.stop();\n    setState(p => ({ ...p, play: false, pause: false }));\n  };\n\n  const pause = () => {\n    // if(!anim) return;\n    // if(state.pause != props.isPaused)\n    setState(p => ({ ...p, pause: true }));\n    /*\n    if (props.isPaused && !anim.isPaused) {\n      // anim.pause();\n      setState(p=>({...p, pause: true}));\n    } else if (!props.isPaused && anim.isPaused) {\n      anim.pause();\n    }*/\n  };\n\n  const destroy = _anim => {\n    _anim = _anim || anim;\n    _anim.destroy();\n  };\n\n  const registerEvents = (eventListeners, _anim) => {\n    if (!eventListeners) return;\n    _anim = _anim || anim;\n    eventListeners.forEach(eventListener => {\n      _anim.addEventListener(eventListener.eventName, eventListener.callback);\n    });\n  };\n\n  const deRegisterEvents = (eventListeners, _anim) => {\n    if (!eventListeners) return;\n    _anim = _anim || anim;\n    eventListeners.forEach(eventListener => {\n      _anim.removeEventListener(eventListener.eventName, eventListener.callback);\n    });\n  };\n\n  // componentDidUpdate\n  useEffect(() => {\n    if (props.animationData !== animationDataPrev) {\n      setAnimationDataPrev(animationData);\n    }\n\n    if (props.isStopped) stop();\n    else if (props.segments && props.segments !== state.segments) {\n      const shouldForce = !!props.forceSegments;\n      playSegments(props.segments, shouldForce);\n    } else {\n      play();\n      // console.log('aw')\n    }\n\n    if (props.isPaused) pause();\n    if (props.speed) setSpeed(props.speed);\n    if (props.direction) setDirection(props.direction);\n\n    // setAnimationControl();\n  }, [props, animationDataPrev]);\n\n  useEffect(() => {\n    options.container = el.current;\n\n    const _anim = lottie.loadAnimation(options);\n    const _animApi = lottieApi.createAnimationApi(_anim);\n    setAnim(_anim);\n    setAnimApi(_animApi);\n\n    setSpeed(props.speed);\n    // setDirection();\n    registerEvents(eventListeners, _anim);\n    setAnimationControl(_animApi);\n\n    return () => {\n      deRegisterEvents(props.eventListeners, _anim);\n      destroy(_anim);\n      // options.animationData = null;\n      // setAnim(null);\n      // setAnimApi(null);\n    };\n  }, [el, animationDataPrev]);\n\n  useEffect(() => {\n    if (!anim) return;\n    if (state.pause) anim.pause();\n    else if (state.segments) anim.playSegments(state.segments, state.shouldForce);\n    else if (state.play === true) anim.play();\n    else if (state.play === false) anim.stop();\n\n    if (state.speed) anim.setSpeed(state.speed);\n    if (state.direction) anim.setDirection(state.direction);\n    // setSpeed(state.speed);\n    // (state.direction);\n  }, [state, anim]);\n\n  useImperativeHandle(ref, () => ({\n    play: play,\n    registerEvents: registerEvents,\n    deRegisterEvents: deRegisterEvents,\n    setSpeed: setSpeed,\n    setDirection: setDirection,\n    anim: anim,\n    animApi: animApi,\n    playSegments: playSegments,\n    pause: pause,\n    destroy: destroy,\n    stop: stop\n  }));\n\n  // Render\n  const { width, height, ariaRole, ariaLabel, title } = props;\n\n  const getSize = initial => {\n    let size;\n\n    if (typeof initial === 'number') {\n      size = `${initial}px`;\n    } else {\n      size = initial || '100%';\n    }\n\n    return size;\n  };\n\n  const lottieStyles = {\n    width: getSize(width),\n    height: getSize(height),\n    overflow: 'hidden',\n    margin: '0 auto',\n    outline: 'none',\n    ...props.style\n  };\n\n  return (\n    // Bug with eslint rules https://github.com/airbnb/javascript/issues/1374\n    // eslint-disable-next-line jsx-a11y/no-static-element-interactions\n    <div ref={el} style={lottieStyles} title={title} role={ariaRole} aria-label={ariaLabel} tabIndex=\"0\" />\n  );\n});\n\n/*\nref={(c) => {\n        el = c;\n      }}\n*/\n\n/*\ntype LottieTypes = {\n  eventListeners: PropTypes.arrayOf(PropTypes.object),\n  options: PropTypes.object.isRequired,\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  isStopped: PropTypes.bool,\n  isPaused: PropTypes.bool,\n  speed: PropTypes.number,\n  segments: PropTypes.arrayOf(PropTypes.number),\n  forceSegments: PropTypes.bool,\n  direction: PropTypes.number,\n  ariaRole: PropTypes.string,\n  ariaLabel: PropTypes.string,\n  title: PropTypes.string,\n  style: PropTypes.string,\n};\n\nLottie.defaultProps = {\n  eventListeners: [],\n  isStopped: false,\n  isPaused: false,\n  speed: 1,\n  ariaRole: 'button',\n  ariaLabel: 'animation',\n  title: '',\n  options: PropTypes.object.isRequired\n};\n*/\n"],"mappings":"AAMA","sourceRoot":""}